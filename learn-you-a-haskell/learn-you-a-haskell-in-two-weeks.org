-*- coding: utf-8-emacs -*-
#+title: Learn You A Haskell In Two Weeks
#+haskell_load_module: "SessionManager"

* 문서 정리
** regex
!!Must be done in vim!!
%s/\(ghci>.*\n\)\@<=#+end_example//g
17
%s/\(^\S[^=]*\n\)\@<=#+end_example//g
461
%s/#+begin_example\(\nghci>\)\@=//g
438
%s/\(^ghci>.*\)\(^ghci> \(.*\)\)\@<=\n\(^ghci>\)\@!\([^#]*\n\)/#\+BEGIN_SRC haskell :session ex\r:{\r\3\r-- \5:}\r#+END_SRC\r/g
%s/\(^ghci>.*\)\(^ghci> let \(.*\)\)\@<=\n/#\+BEGIN_SRC haskell :session ex\r:{\r\3\r:}\r#\+END_SRC\r/g
%s/\(^ghci>.*\)\(^ghci> \(.*\)\)\@<=\n/#\+BEGIN_SRC haskell :session ex\r:{\r\3\r:}\r#\+END_SRC\r/g
%s/ghci>\n//g
30,$s/#+begin_example/#+BEGIN_SRC haskell
30,$s/#+end_example/:}\r#+END_SRC/g
** clear
#+BEGIN_SRC emacs-lisp :results none
(let ((MATCH t)
      (SCOPE nil)
      (SKIP nil)
      (spacing nil))

  (org-map-entries
   (lambda ()
     (let ((name (nth 4 (org-heading-components))))
       (if (string= name "A.")
           (save-restriction
             (org-mark-subtree)
             ;;(forward-line) ;; keep header
             (delete-region (region-beginning) (region-end))
             ))
       )) MATCH SCOPE SKIP))
#+END_SRC


* 리스트와 튜플, 그리고 함수의 기초
** 데이터 구조로써 리스트가 갖는 특징은?
*** .
**** 동일한 타입의 데이터를
**** 0개 이상 가질 수 있다
**** ex
#+BEGIN_SRC haskell
numbers = [4,8,15,16,23,42]
numbers
#+END_SRC

#+BEGIN_SRC haskell
wrongList = [1,2,'a',3,'b','c',4]
#+END_SRC

**** 출처
***** Ch 1 p.8


** 데이터 구조로써 튜플이 갖는 특징은?
*** .
**** 동일하지 않을 수 있는 타입의 데이터를
**** 최소 2개 이상, 고정된 크기로 가져야 한다
**** 크기가 2인 튜플(tuple)을 페어(pair), 3인 튜플을 트리플(triple)이라고 한다
**** ex
#+BEGIN_SRC haskell
("Christopher", "Walken", 55)
#+END_SRC

**** 출처
***** Ch 1 pp.20,21


** 리스트, 페어 항목에 접근하는 방법은?
*** .
**** 리스트 : `!!` 이용
**** 페어 : `fst`, `snd` 이용
**** ex
#+BEGIN_SRC haskell
[9.4,33.2,96.2,11.2,23.25] !! 1
#+END_SRC

#+BEGIN_SRC haskell
:{
fst (8,11)
-- 8
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
snd ("Wow", False)
-- False
:}
#+END_SRC
**** 출처
***** Ch 1 pp.9,21,22


*** Q.
리스트 a = [1,2,3,4,5,6,7,8,9,10] 가 주어졌을 때, 3번째 원소인 3에 접근하려면?
#+BEGIN_SRC haskell
:{
a = [1,2,3,4,5,6,7,8,9,10]
:}
-- Answer

#+END_SRC

** 리스트를 연결하는 방법은?
*** .
**** `++` 이용
**** `:` 이용
**** ex
#+BEGIN_SRC haskell
[1,2,3,4] ++ [9,10,11,12]
#+END_SRC

#+BEGIN_SRC haskell
['w','o'] ++ ['o','t']
#+END_SRC

#+BEGIN_SRC haskell
1:[2,3,4,5]
#+END_SRC

#+BEGIN_SRC haskell
[2,3,4,5]:[1]
#+END_SRC

#+BEGIN_SRC haskell
5:[] == [5]
#+END_SRC

#+BEGIN_SRC haskell
1:2:3:4:5:[] == [1,2,3,4,5]
#+END_SRC

#+BEGIN_SRC haskell
[1,2,3,4,5,6,7,8,9] ++ [10]
#+END_SRC

#+BEGIN_SRC haskell
[1] ++ [2,3,4,5,6,7,8,9]
#+END_SRC

**** 출처
***** Ch 1 pp.8,9


*** Q.
리스트 a = [1,2,3,4,5] b = [6,7,8,9,10] 가 주어졌을 때, a와 b를 연결하는 방법은?
#+BEGIN_SRC haskell
:{
a = [1,2,3,4,5]
b = [6,7,8,9,10]
:}
-- Answer

#+END_SRC

** 참고
*** .
**** 리스트 안의 리스트도 만들 수 있다
**** 리스트, 튜플끼리 비교가 가능하다
**** ex
#+BEGIN_SRC haskell
b = [[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]]
:{
b
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
b ++ [[1,1,1,1]]
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
[6,6,6]:b
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
b !! 2
:}
#+END_SRC

#+BEGIN_SRC haskell
[3,2,1] > [2,1,0]
#+END_SRC

#+BEGIN_SRC haskell
[3,2,1] > [2,10,100]
#+END_SRC

#+BEGIN_SRC haskell
[3,4,2] > [3,4]
#+END_SRC

#+BEGIN_SRC haskell
[3,4,2] > [2,4]
#+END_SRC

**** 출처
***** Ch 1 pp.9,10


*** .
**** 문자열은 문자 타입의 데이터로 구성된 리스트다
**** ex
#+BEGIN_SRC haskell
['h','e','l','l','o'] == "hello"
#+END_SRC

**** 출처
***** Ch 1 p.8


*** .
**** 리스트를 범위 (표기 : `..`) 를 사용해서 표현할 수 있다
**** ex
#+BEGIN_SRC haskell
:{
[1..20]
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
['a'..'z']
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
['K'..'Z']
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
[2,4..20]
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
[3,6..20]
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
[0.1, 0.3 .. 1]
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
[20,19..1]
:}
#+END_SRC

**** 출처
***** Ch 1 pp.14~16


*** .
**** 전위 함수를 중위 함수로 만들기
**** ex
#+BEGIN_SRC haskell
:{
div 92 10
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
92 `div` 10
:}
#+END_SRC

**** 출처
***** Ch 1 p.5


*** .
**** 리스트에 대한 다양한 함수들
***** `head`
***** `tail`
***** `init`
***** `last`
***** `length`
***** `null`
***** `reverse`
***** `take`
***** `cycle`
***** `repeat`
***** `drop`
***** `maximum`
***** `minimum`
***** `sum`
***** `elem`
**** ex
#+BEGIN_SRC haskell
:{
head [5,4,3,2,1]
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
tail [5,4,3,2,1]
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
last [5,4,3,2,1]
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
init [5,4,3,2,1]
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
length [5,4,3,2,1]
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
null [1,2,3]
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
null []
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
reverse [5,4,3,2,1]
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
take 3 [5,4,3,2,1]
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
take 5 [1,2]
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
take 0 [6,6,6]
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
take 24 [13,26..]
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
take 10 (cycle [1,2,3])
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
take 12 (cycle "LOL ")
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
take 10 (repeat 5)
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
drop 3 [8,4,2,1,5,6]
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
drop 0 [1,2,3,4]
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
drop 100 [1,2,3,4]
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
minimum [8,4,2,1,5,6]
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
maximum [1,9,2,3,4]
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
sum [5,2,1,6,3,2,5,7]
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
product [6,2,1,2]
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
4 `elem` [3,4,5,6]
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
10 `elem` [3,4,5,6]
:}
#+END_SRC

**** 출처
***** Ch 1 pp.11~13


*** .
**** 튜플에 대한 다양한 함수들
***** `zip`
**** ex
#+BEGIN_SRC haskell
:{
zip [1,2,3,4,5] [5,5,5,5,5]
-- [(1,5),(2,5),(3,5),(4,5),(5,5)]
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
zip [1 .. 5] ["one", "two", "three", "four", "five"]
-- [(1,"one"),(2,"two"),(3,"three"),(4,"four"),(5,"five")]
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
zip [5,3,2,6,2,7,2,5,4,6,6] ["im","a","turtle"]
-- [(5,"im"),(3,"a"),(2,"turtle")]
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
zip [1..] ["apple", "orange", "cherry", "mango"]
-- [(1,"apple"),(2,"orange"),(3,"cherry"),(4,"mango")]
:}
#+END_SRC

**** 출처
***** Ch 1 p.22


** 리스트의 조건제시법을 표현하는 방법은?
*** .
**** 수학의 조건제시법과 매우 유사함
리스트 조건제시법 명칭 사용례(https://formal.hknu.ac.kr/Gongsu-DataSci/notebooks/GongSu11_List_Comprehension.html)
**** ex
#+BEGIN_SRC haskell
:{
[ 2*n | n <- [1..10], 2*n >= 12]
:}
#+END_SRC

#+BEGIN_SRC python
[ 2*n for n in range(1,11) if 2*n >= 12]
#+END_SRC

#+BEGIN_SRC haskell
:{
[ x | x <- [10..20], x /= 13, x /= 15, x /= 19]
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
[ x*y | x <- [2,5,10], y <- [8,10,11]]
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
[1 | _ <- [1,2,3,4]]
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
triangles = [ (a,b,c) | c <- [1..10], b <- [1..10], a <- [1..10] ]
:}

**** 출처
***** Ch 1 pp.16~19,22~24


*** Q.
"Hahaha! Ahahaha!"에서 대문자만을 남기는 방법은?
#+BEGIN_SRC haskell
:{

:}
#+END_SRC

*** Q.
[2,5,10] 와 [8,10,11] 사이의 모든 가능한 곱에 대해서 50보다 큰 수를 뽑아내면?
#+BEGIN_SRC haskell
:{
-- Answer

:}
#+END_SRC

*** Q.
50 에서 100 의 숫자 중에서 7로 나눴을 때 나머지가 3인 숫자들은?
- mod x y : x를 y로 나눴을 때의 나머지
#+BEGIN_SRC haskell
:{

:}
#+END_SRC

*** Q.
7에서 13의 리스트 중 홀수를 골라서 10보다 작으면 "BOOM!", 그 외에는 "BANG!"으로 치환된 리스트를 만들면?
- odd x : x가 홀수이면 True
#+BEGIN_SRC haskell
:{

:}
#+END_SRC

*** Q.
xxs = [[1,3,5,2,3,1,2,4,5],[1,2,3,4,5,6,7,8,9],[1,2,4,2,1,6,3,1,3,2,3,6]]가 주어졌을 때 짝수만 남기면?
#+BEGIN_SRC haskell
:{
xxs = [[1,3,5,2,3,1,2,4,5],[1,2,3,4,5,6,7,8,9],[1,2,4,2,1,6,3,1,3,2,3,6]]
:}
:{

:}
#+END_SRC

*** Q.
세변의 길이가 모두 정수이고, 각변의 길이는 10보다 작거나 같은 삼각형을 변을 튜플의 리스트로 나타내면?
#+BEGIN_SRC haskell
:{

:}
#+END_SRC

** 함수를 정의하는 구문은?
*** .
**** <함수이름> <본문에서 쓰일 인자1> <인자2> ... = <본문>
**** ex
#+BEGIN_SRC haskell
:{
doubleMe x = x + x
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
doubleUs x y = x*2 + y*2
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
doubleUs 28 88 + doubleMe 123
-- 478
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
doubleUs2 x y = doubleMe x + doubleMe y
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
doubleSmallNumber x = if x > 100
                        then x
                        else x*2
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
doubleSmallNumber' x = (if x > 100 then x else x*2) + 1
:}
#+END_SRC

**** 출처
***** Ch 1 pp.5~7


** 참고
*** .
**** 하스켈에서 함수를 적용하는 것은 모든 연산자들 중에 가장 높은 우선순위를 갖는다
**** ex
#+BEGIN_SRC haskell
:{
succ 9 * 10
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
succ (9 * 10)
:}
#+END_SRC

**** 출처
***** Ch 1 pp.4



*** .
**** 파일 로드 방법
**** ex
#+BEGIN_SRC haskell
:! pwd
#+END_SRC

#+BEGIN_SRC haskell
:cd ..
#+END_SRC

#+BEGIN_SRC haskell
:l baby
#+END_SRC

#+BEGIN_SRC haskell
:l /path-to-baby/baby.hs
#+END_SRC

#+BEGIN_SRC haskell
tripleTest 4
#+END_SRC

#+BEGIN_SRC haskell :results output
:l Main
#+END_SRC

#+BEGIN_SRC haskell :results output
main
#+END_SRC

**** 출처
***** Ch 1 p.5



*** .
**** 하스켈에서 모든 함수는 하나의 인자만 받는다
**** 두개의 인자를 받으려면 커리된 함수(curried function)로 만들어야함
**** 커리된 함수에서 인자를 부족하게 주면 부분 적용된 함수(partially applied function)이다
**** 중위 함수에 인자를 부분적으로 적용하는 것을 섹션이라고 한다
**** ex
#+BEGIN_SRC haskell
:{
max 4 5
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
(max 4) 5
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
--multThree :: (Num a) => a -> a -> a -> a
multThree x y z = x * y * z

multTwoWithNine = multThree 9
multWithEighteen = multTwoWithNine 2
:}
#+END_SRC

#+BEGIN_SRC haskell
multTwoWithNine 2 3
#+END_SRC

#+BEGIN_SRC haskell
multWithEighteen 10
#+END_SRC

#+BEGIN_SRC haskell
:{
-- divideByTen :: (Floating a) => a -> a
divideByTen = (/10)
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
-- isUpperAlphanum :: Char -> Bool
isUpperAlphanum = (`elem` ['A'..'Z'])
:}
#+END_SRC

**** 출처
***** Ch 5 pp.63~67


** 패턴 매칭의 구문은?
*** .
**** 패턴 매칭
**** 'as' patterns
**** ex
#+BEGIN_SRC haskell
:{
-- lucky :: (Integral a) => a -> String
lucky 7 = "LUCKY NUMBER SEVEN!"
lucky x = "Sorry, you're out of luck, pal!"
:}
lucky 7
#+END_SRC

#+BEGIN_SRC haskell
lucky 8
#+END_SRC

#+BEGIN_SRC haskell
:{
-- sayMe :: (Integral a) => a -> String
sayMe 1 = "One!"
sayMe 2 = "Two!"
sayMe 3 = "Three!"
sayMe 4 = "Four!"
sayMe 5 = "Five!"
sayMe x = "Not between 1 and 5"
:}
sayMe 3
#+END_SRC

#+BEGIN_SRC haskell
:{
-- factorial :: (Integral a) => a -> a
factorial 0 = 1
factorial n = n * factorial (n - 1)
:}
factorial 10
#+END_SRC

#+BEGIN_SRC haskell
:{
-- charName :: Char -> String
charName 'a' = "Albert"
charName 'b' = "Broseph"
charName 'c' = "Cecil"
:}
charName 'h'
#+END_SRC

#+BEGIN_SRC haskell
:{
-- addVectors :: (Num a) => (a, a) -> (a, a) -> (a, a)
addVectors a b = (fst a + fst b, snd a + snd b)
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
-- addVectors :: (Num a) => (a, a) -> (a, a) -> (a, a)
addVectors (x1, y1) (x2, y2) = (x1 + x2, y1 + y2)
:}
addVectors (1,2) (3,6)
#+END_SRC

#+BEGIN_SRC haskell
:{
--first :: (a, b, c) -> a
first (x, _, _) = x

--second :: (a, b, c) -> b
second (_, y, _) = y

--third :: (a, b, c) -> c
third (_, _, z) = z
:}
second (1,2,3)
#+END_SRC

#+BEGIN_SRC haskell
:{
xs = [(1,2), (2,3), (3,4), (4,5), (5,6), (6,7), (7,8), (8,9)]
:}
:{
[a+b | (a,b) <- xs]
:}
#+END_SRC

#+RESULTS:
: ghci| ghci| [4,7,6,8,11,4]

#+BEGIN_SRC haskell
:{
[ a+b | ((a,b),c) <- zip xs [1..], c `mod` 4 == 0 ]
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
powerOfTwo 1 = True
powerOfTwo x = even x && powerOfTwo (x `div` 2)
:}
[ a+b | ((a,b),c) <- zip xs [1..], powerOfTwo c ]
#+END_SRC

#+RESULTS:
| 3 | 5 | 9 | 17 |

#+BEGIN_SRC haskell
:{
-- capital :: String -> String
capital "" = "Empty string, whoops!"
capital all@(x:xs) = "The first letter of " ++ all ++ " is " ++ [x]
:}
capital "Dracula"
#+END_SRC

**** 출처
***** Ch 3 pp.37~43



*** Q.
숫자의 리스트가 비어있으면 0, 요소가 1개면 그 값, 요소가 2개면 두 값의 합, 요소가 3개 이상이면 -1을 돌려주는 함수 tell을 만들면?
#+BEGIN_SRC haskell
:{

:}
tell [3,4]
#+END_SRC

*** Q.
리스트를 받아서 그 리스트의 길이를 알려주는 함수 length를 만들면?
#+BEGIN_SRC haskell
:{

:}
length' [3,4]
#+END_SRC

*** Q.
sum 함수를 패턴매칭과 간단한 재귀로 만들어보면?
#+BEGIN_SRC haskell
:{

:}
sum' [3..13]
#+END_SRC

** `map`과 `filter`를 쓰는 방법은? -
*** .
**** `map` : 함수와 리스트를 받아서 리스트의 각 원소에 함수를 적용함
#+BEGIN_SRC haskell
:{
-- map :: (a -> b) -> [a] -> [b]
map _ [] = []
map f (x:xs) = f x : map f xs
:}
#+END_SRC
**** `filter` : 함수와 리스트를 받아서 리스트의 각 원소에 함수를 적용한 결과가 `True`일 경우에만 리스트에 포함
#+BEGIN_SRC haskell
:{
-- filter :: (a -> Bool) -> [a] -> [a]
filter _ [] = []
filter p (x:xs)
    | p x       = x : filter p xs
    | otherwise = filter p xs
:}
#+END_SRC
**** ex
#+BEGIN_SRC haskell
:{
[x+3 | x <- [1,5,3,1,6]]
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
map (+3) [1,5,3,1,6]
:}
#+END_SRC

#+BEGIN_SRC haskell
  map (+3) [1,5,3,1,6]
= [(+3) 1,(+3) 5,(+3) 3,(+3) 1,(+3) 6]
= [4, 8, 6, 4, 6]
#+END_SRC

#+BEGIN_SRC haskell
:{
map fst [(1,2),(3,5),(6,3),(2,6),(2,5)]
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
map (++ "!") ["BIFF", "BANG", "POW"]
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
map (replicate 3) [3..6]
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
map (map (^2)) [[1,2],[3,4,5,6],[7,8]]
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
filter (>3) [1,5,3,2,1,6,4,3,2,1]
-- [5,6,4]
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
filter (==3) [1,2,3,4,5]
-- [3]
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
filter even [1..10]
-- [2,4,6,8,10]
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
let notNull x = not (null x) in filter notNull [[1,2,3],[],[3,4,5],[2,2],[],[],[]]
-- [[1,2,3],[3,4,5],[2,2]]
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
filter (`elem` ['a'..'z']) "u LaUgH aT mE BeCaUsE I aM diFfeRent"
-- "uagameasadifeent"
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
filter (`elem` ['A'..'Z']) "i Laugh At you Because u R All The Same"
-- "LABRATS"
:}
#+END_SRC

**** 출처
***** Ch 5 pp.70~75


*** Q.
0을 곱하는 함수, 1을 곱하는 함수, 3을 곱하는 함수 ... 로 구성된 무한 리스트를 만들면?
#+BEGIN_SRC haskell
:{
-- Answer
listOfFuns =
:}
(listOfFuns !! 4) 5
#+END_SRC
*** TODO Q.
숫자의 리스트가 비어있으면 0, 요소가 1개면 그 값, 요소가 2개면 두 값의 합, 요소가 3개 이상이면 -1을 돌려주는 함수 tell을 만들면?
#+BEGIN_SRC haskell
:{
-- Answer

:}
tell [3,4]
#+END_SRC
** 람다의 구문은?
*** .
**** 단 한 번만 함수가 필요할 때 사용하는 익명 함수
**** \<인자1> <인자2> ... -> <본문>
**** ex
#+BEGIN_SRC haskell
:{
-- addThree :: (Num a) => a -> a -> a -> a
addThree x y z = x + y + z
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
-- addThree :: (Num a) => a -> a -> a -> a
addThree = \x -> \y -> \z -> x + y + z
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
map (\(a,b) -> a + b) [(1,2),(3,5),(6,3),(2,6),(2,5)]
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
--flip' :: (a -> b -> c) -> b -> a -> c
flip' f x y = f y x
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
--flip' :: (a -> b -> c) -> b -> a -> c
flip' f = \x y -> f y x
:}
#+END_SRC

**** 출처
***** Ch 5 pp.75~77


** `foldl`, `foldr`를 쓰는 방법은?
*** .
**** 이진 함수(ex. `+`), 시작값(or 누적값), 리스트를 받아서 하나의 값을 반환
**** ex
#+BEGIN_SRC haskell
:{
-- sumByFold :: (Num a) => [a] -> a
sumByFold xs = foldl (\acc x -> acc + x) 0 xs
:}
sumByFold [3,5,2,1]
#+END_SRC

#+BEGIN_SRC haskell
  foldl (\acc x -> acc + x) 0 [3,5,2,1]
= foldl (\acc x -> acc + x) (0+3) [5,2,1]
= foldl (\acc x -> acc + x) ((0+3)+5) [2,1]
= foldl (\acc x -> acc + x) (((0+3)+5)+2) [1]
= foldl (\acc x -> acc + x) ((((0+3)+5)+2)+1) []
= ((((0+3)+5)+2)+1)
#+END_SRC

#+BEGIN_SRC haskell
  foldr (\x acc -> x + acc) 0 [3,5,2,1]
= foldr (\x acc -> x + acc) (1+0) [3,5,2]
= foldr (\x acc -> x + acc) (2+(1+0)) [3,5]
= foldr (\x acc -> x + acc) (5+(2+(1+0))) [3]
= foldr (\x acc -> x + acc) (3+(5+(2+(1+0)))) []
= (3+(5+(2+(1+0))))
#+END_SRC

#+BEGIN_SRC haskell
:{
sumByFold :: (Num a) => [a] -> a
sumByFold = foldl (+) 0
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
elem' :: (Eq a) => a -> [a] -> Bool
elem' y ys = foldl (\acc x -> if x == y then True else acc) False ys
-- 혹은 elem' y ys = foldl (\acc x -> x == y || acc) False ys
:}
elem' 7 [5,3,4]
#+END_SRC

#+BEGIN_SRC haskell
:{
map' :: (a -> b) -> [a] -> [b]
map' f xs = foldr (\x acc -> f x : acc) [] xs
:}
#+END_SRC
**** 출처
***** Ch 5 pp.77~82


*** Q.
product 함수를 foldl로 구현하면?
#+BEGIN_SRC haskell
:{
-- Answer

:}
productByFold [3,5,2,1]
#+END_SRC

*** Q.
reverse 함수를 foldl로 구현하면?
#+BEGIN_SRC haskell
:{
-- Answer
reverse' =
:}
:{
reverse' [1..10]
:}
#+END_SRC

* 타입
** 타입이란?
*** .
**** 타입은 값의 종류를 뜻하는 레이블이라 생각할 수 있다
**** 모든 표현식은 타입을 갖는다
***** 하스켈에서 값(value)을 반환하는 코드 조각을 표현식(expression)이라고 한다
***** 함수도 표현식이기 때문에 타입을 갖는다
***** 튜플은 요소들의 길이와 타입에 따라 정의되는 타입을 갖는다
**** 대표적인 하스켈 타입
***** `Int`
: 최솟값, 최댓값 존재
***** `Integer`
: 한계가 없음
***** `Float`
: 단정밀도(single precision) 부동소수점수
***** `Double`
: 배정밀도(double precision) 부동소수점수
***** `Bool`
: 불리언 타입
***** `Char`
: 유니코드 문자
**** ex
#+BEGIN_SRC haskell
:{
:t 'a'
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
:t True
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
:t "HELLO!"
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
:t (True, 'a')
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
:t ('a','b','c')
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
:t 4 == 5
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
leaveOnlyUppercase st = [ c | c <- st, c `elem` ['A'..'Z']]
:}
:t leaveOnlyUppercase
#+END_SRC

#+BEGIN_SRC haskell
:{
-- addThree :: Int -> Int -> Int -> Int
addThree x y z = x + y + z
:}
#+END_SRC

**** 출처
******* Ch 2 pp.25~28



** 타입 변수(타입 매개변수)란?
*** .
**** 여러 가지 타입에서 동작하는 함수들의 타입을 어떻게 표현할 것인가?
***** 타입 변수 : 임의의 타입 생성자 및 구체적인 타입(concrete type)을 부르는 상황에서 주로 쓰임
***** 타입 매개변수 : "타입 생성자 뒤에 적용되는" 임의의 타입을 부르는 상황을 강조할 때 주로 쓰임
**** 타입 변수를 사용하는 함수를 다형 함수(polymorphic function)라 부른다
**** ex
#+BEGIN_SRC haskell
:{
:t head
-- head :: [a] -> a
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
:t fst
-- fst :: (a, b) -> a
:}
#+END_SRC

**** 출처
******* Ch 2 pp.28~29


** 타입을 새롭게 선언하는 구문은?
*** .
**** data <타입 생성자 + (타입 변수)> = <값 생성자 + (타입 변수), `|`의 조합> deriving <타입클래스>
***** 값 생성자(value constructor)는 입력값으로 0개 이상의 타입을 받아 타입을 출력하는 함수이다
#+BEGIN_SRC haskell
:t Circle
#+END_SRC

#+BEGIN_SRC haskell
:t Rectangle
#+END_SRC

#+BEGIN_SRC haskell
:t Just
#+END_SRC

***** 타입 변수는 값 생성자들에 다양한 타입이 적용될 수 있는 타입일 때 쓰인다.
**** ex
#+BEGIN_SRC haskell
data Bool = False | True
#+END_SRC

#+BEGIN_SRC haskell
data Shape = Circle Float Float Float | Rectangle Float Float Float Float deriving (Show)
#+END_SRC

#+BEGIN_SRC haskell
:{
surface :: Shape -> Float
surface (Circle _ _ r) = pi * r ^ 2
surface (Rectangle x1 y1 x2 y2) = (abs $ x2 - x1) * (abs $ y2 - y1)
:}
#+END_SRC

#+BEGIN_SRC haskell
surface $ Circle 10 20 10
#+END_SRC

#+BEGIN_SRC haskell
surface $ Rectangle 0 0 100 100
#+END_SRC

#+BEGIN_SRC haskell
Circle 10 20 5
#+END_SRC

#+BEGIN_SRC haskell
:{
map (Circle 10 20) [4,5,6,6]
:}
#+END_SRC

#+BEGIN_SRC haskell
data Maybe a = Nothing | Just a
#+END_SRC

#+BEGIN_SRC haskell
:{
:t Just "Haha"
-- Just "Haha" :: Maybe [Char]
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
:t Just 84
-- Just 84 :: (Num t) => Maybe t
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
:t Nothing
-- Nothing :: Maybe a
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
Just 10 :: Maybe Double
-- Just 10.0
:}
#+END_SRC
**** 출처
***** Ch 7 pp.113~117,121~125





*** Q.
#+BEGIN_SRC haskell
:{
data Shape = Circle Float Float Float | Rectangle Float Float Float Float

surface :: Shape -> Float
surface (Circle _ _ r) = pi * r ^ 2
surface (Rectangle x1 y1 x2 y2) = (abs $ x2 - x1) * (abs $ y2 - y1)
:}
surface (Circle 10 20 10)
#+END_SRC

위의 `Shape` 타입을 아래와 같이 바꿨을 때 그에 맞춰서 `surface` function을 다시 짜면?
#+BEGIN_SRC haskell
:{
data Point = Point Float Float deriving (Show)
data Shape = Circle Point Float | Rectangle Point Point deriving (Show)
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
-- Answer

:}
surface
#+END_SRC

** 참고
*** .
**** 타입 동의어(type synonym) : 매개변수화된 타입을 만들거나 가독성을 높일 때 사용
**** ex
#+BEGIN_SRC haskell
type String = [Char]
#+END_SRC

#+BEGIN_SRC haskell
type AssocList k v = [(k,v)]
#+END_SRC

#+BEGIN_SRC haskell
type IntMap v = Map Int v
#+END_SRC

#+BEGIN_SRC haskell
type IntMap = Map Int
#+END_SRC

**** 출처
***** Ch 7 pp.132~135


*** .
**** newtype 구문 : 값 생성자가 오직 한개이고 타입도 오직 한 개일 때만 가능
***** data 구문에서처럼 상자 안에 데이터가 넣는 상황보다는 하나의 타입에서 다른 타입으로 직접 변환하는 상황에서 쓰임
***** data 구문 보다 overhead가 적다
**** 타입 동의어와의 비교
***** 공통점 : 기존의 타입을 새로운 타입으로 바꿈
***** 차이점 : 컴파일 시에 구분이 되는지 여부
**** ex
#+BEGIN_SRC haskell
:{
data ZipList a = ZipList [a]
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
newtype ZipList a = ZipList [a]
:}
#+END_SRC

**** 출처
***** Ch 12 pp.257~264


** 재귀적인 데이터 구조란?
*** .
**** 값 생성자는 여러 타입(혹은 타입 변수)를 받을 수 있는 함수이다
**** 타입을 자기 자신으로 표현하여 선언할 수 있다.
**** ex

#+BEGIN_SRC haskell
data [] a = [] | a : [a]
#+END_SRC

#+BEGIN_SRC haskell
data List a = Empty | a : (List a)
data List a = Empty | (:) a (List a)
data List a = Empty | Cons a (List a)
#+END_SRC

#+BEGIN_SRC haskell
data List a = Empty | Cons a (List a) deriving (Show, Read, Eq, Ord)
#+END_SRC

#+BEGIN_SRC haskell
5 `Cons` Empty
#+END_SRC

#+BEGIN_SRC haskell
4 `Cons` (5 `Cons` Empty)
#+END_SRC

**** 출처
***** Ch 7 pp.138~139
***** https://hackage.haskell.org/package/ghc-prim-0.9.0/docs/src/GHC.Types.html
***** (https://hackage.haskell.org/package/base-4.18.0.0/docs/src/GHC.Base.html)


** 참고
*** .
**** 대수적 데이터 타입(Algebraic Data Type)
***** 타입에 대해 덧셈 뺄셈 곱셈 나눗셈을 할 수 있다
**** ex
#+BEGIN_SRC haskell
data List a = [] | a:(List a)

data List a = [] | (:) a (List a)

data List a = Nil | Cons a (List a)
#+END_SRC

      $L = 1 + X \cdot L$



$\Leftrightarrow L \cdot (1 - X) = 1$


$\Leftrightarrow L = \frac{1}{1-X} = 1 + X  + X^2 + X^3 + \cdots = 1 + X\cdot 1 + X^2\cdot 1 + X^3\cdot 1 + \cdots$

#+BEGIN_SRC haskell
data List a = [] | a:[] | a:a:[] | a:a:a:[] | ...
#+END_SRC

**** 출처
***** https://math.stackexchange.com/questions/50375/whats-the-meaning-of-algebraic-data-type/106889#106889


** 타입클래스란?
*** .
**** 어떤 동작을 정의하는 인터페이스
**** A 타입이 B 타입클래스의 인스턴스라면 A 타입은 B 타입클래스가 기술한 동작(=함수)을 지원하며 구현한다
***** 타입클래스가 어떤 함수를 구현하기를 요구하는지가 핵심!
**** 대표적인 타입클래스
***** `Eq`
: 값이 같은지 다른지 확인할 수 있는 타입들
#+BEGIN_SRC haskell
:i Eq
#+END_SRC

***** `Ord`
: 값들에 순서가 있는 타입들
#+BEGIN_SRC haskell
:i Ord
#+END_SRC

#+BEGIN_SRC haskell
:i Ordering
#+END_SRC

***** `Show`
: 문자열처럼 표시될 수 있는 타입들
#+BEGIN_SRC haskell
:i Show
#+END_SRC

***** `Read`
: 문자열을 받아서 타입으로 바꿀 수 있는 타입들
#+BEGIN_SRC haskell
:i Read
#+END_SRC

***** `Enum`
: 연속적으로 순서가 있는 타입들
#+BEGIN_SRC haskell
:i Enum
#+END_SRC

***** `Bounded`
: 상한과 하한이 있는 타입들
#+BEGIN_SRC haskell
:i Read
#+END_SRC

***** `Num`
: 사칙연산을 하는 숫자처럼 동작할 수 있거나, 그런 연산을 다루는 숫자인 타입들
#+BEGIN_SRC haskell
:i Num
#+END_SRC

***** `Floating`
: 부동소수점수를 구현하는 타입들
#+BEGIN_SRC haskell
:i Floating
#+END_SRC

***** `Integral`
: 정수에서 쓰이는 연산을 하는 숫자처럼 동작할 수 있거나, 그런 연산을 다루는 숫자인 타입들
#+BEGIN_SRC haskell
:i Integral
#+END_SRC

**** ex
#+BEGIN_SRC haskell
:{
:t (==)
-- (==) :: (Eq a) => a -> a -> Bool
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
5 == 5
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
5 /= 5
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
:t (>)
-- (>) :: (Ord a) => a -> a -> Bool
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
:t compare
-- compare :: Ord a => a -> a -> Ordering
:}
#+END_SRC

#+BEGIN_SRC haskell
"Abrakadabra" < "Zebra"
#+END_SRC

#+BEGIN_SRC haskell
"Abrakadabra" `compare` "Zebra"
#+END_SRC

#+BEGIN_SRC haskell
5 >= 2
#+END_SRC

#+BEGIN_SRC haskell
5 `compare` 3
#+END_SRC

#+BEGIN_SRC haskell
EQ `compare` LT
#+END_SRC

#+BEGIN_SRC haskell
show 3
#+END_SRC

#+BEGIN_SRC haskell
show True
#+END_SRC

#+BEGIN_SRC haskell
read "True" || False
#+END_SRC

#+BEGIN_SRC haskell
read "8.2" + 3.8
#+END_SRC

#+BEGIN_SRC haskell
read "[1,2,3,4]" ++ [3]
#+END_SRC

#+BEGIN_SRC haskell
read "4"
#+END_SRC

#+BEGIN_SRC haskell
:{
:t read
-- read :: (Read a) => String -> a
:}
#+END_SRC

#+BEGIN_SRC haskell
read "5" :: Int
#+END_SRC

#+BEGIN_SRC haskell
read "5" :: Float
#+END_SRC

#+BEGIN_SRC haskell
(read "5" :: Float) * 4
#+END_SRC

#+BEGIN_SRC haskell
:{
['a'..'e']
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
[LT .. GT]
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
[3 .. 5]
:}
#+END_SRC

#+BEGIN_SRC haskell
succ 'B'
#+END_SRC

#+BEGIN_SRC haskell
minBound :: Int
#+END_SRC

#+BEGIN_SRC haskell
maxBound :: Char
#+END_SRC

#+BEGIN_SRC haskell
maxBound :: Bool
#+END_SRC

#+BEGIN_SRC haskell
minBound :: Bool
#+END_SRC

#+BEGIN_SRC haskell
:{
maxBound :: (Bool, Int, Char)
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
:t 20
-- 20 :: (Num t) => t
:}
#+END_SRC
:}
#+END_SRC

#+BEGIN_SRC haskell
20 :: Int
#+END_SRC

#+BEGIN_SRC haskell
20 :: Float
#+END_SRC

#+BEGIN_SRC haskell
(5:: Int) * (6 :: Integer)
#+END_SRC

**** 출처
***** Ch 2 pp.29~36


*** .
**** 레코드 구문
**** ex
#+BEGIN_SRC haskell
:{
data Person = Person String String Int Float String String deriving (Show)
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
data Person = Person { firstName :: String
                     , lastName :: String
                     , age :: Int
                     , height :: Float
                     , phoneNumber :: String
                     , flavor :: String
                     } deriving (Show)
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
:t flavor
-- flavor :: Person -> String
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
:t firstName
-- firstName :: Person -> String
:}
#+END_SRC

#+BEGIN_SRC haskell
data Car = Car String String Int deriving (Show)
#+END_SRC


#+BEGIN_SRC haskell
:{
Car "Ford" "Mustang" 1967
-- Car "Ford" "Mustang" 1967
:}
#+END_SRC

#+BEGIN_SRC haskell
data Car = Car {company :: String, model :: String, year :: Int} deriving (Show)
#+END_SRC


#+BEGIN_SRC haskell
:{
Car {company="Ford", model="Mustang", year=1967}
-- Car {company = "Ford", model = "Mustang", year = 1967}
:}
#+END_SRC

**** 출처
***** Ch 7 pp.118~121




*** .
**** 어떤 타입클래스에서 정의된 함수를 값 생성자의 타입(혹은 타입 변수)들이 모두 활용할 수 있을 때
**** 타입 선언 구문의 뒤에 `deriving <typeclass>`를 붙여서 타입클래스를 파생한다.
**** ex
#+BEGIN_SRC haskell
data ShapeTemp = CircleTemp Float Float Float | RectangleTemp Float Float Float Float
#+END_SRC

#+BEGIN_SRC haskell
CircleTemp 10 20 5
#+END_SRC

#+BEGIN_SRC haskell
data Shape = Circle Float Float Float | Rectangle Float Float Float Float deriving (Show)
#+END_SRC

#+BEGIN_SRC haskell
Circle 10 20 5
#+END_SRC

#+BEGIN_SRC haskell
:{
data Person = Person { firstName :: String
                     , lastName :: String
                     , age :: Int
                     } deriving (Eq)

mikeD = Person {firstName = "Michael", lastName = "Diamond", age = 43}
adRock = Person {firstName = "Adam", lastName = "Horovitz", age = 41}
mca = Person {firstName = "Adam", lastName = "Yauch", age = 44}
mikeD2 = Person {firstName = "Michael", lastName = "Diamond", age = 43}
:}
#+END_SRC

#+BEGIN_SRC haskell
mca == adRock
#+END_SRC

#+BEGIN_SRC haskell
mikeD == mikeD2
#+END_SRC

#+BEGIN_SRC haskell
mikeD == Person {firstName = "Michael", lastName = "Diamond", age = 43}
#+END_SRC

#+BEGIN_SRC haskell
beastieBoys = [mca, adRock, mikeD]
mikeD `elem` beastieBoys
#+END_SRC

#+BEGIN_SRC haskell
mikeD
#+END_SRC

#+BEGIN_SRC haskell
"mikeD is: " ++ show mikeD
#+END_SRC

#+BEGIN_SRC haskell
read "Person {firstName = \"Michael\", lastName = \"Diamond\", age = 43}" :: Person
#+END_SRC

#+BEGIN_SRC haskell
:{
data Person3 = Person3 { firstName :: String
                     , lastName :: String
                     , age :: Int
                     } deriving (Eq, Show, Read)
:}

mikeD3 = Person3 {firstName = "Michael", lastName = "Diamond", age = 43}
#+END_SRC

#+BEGIN_SRC haskell
mikeD3
#+END_SRC

#+BEGIN_SRC haskell
"mikeD3 is: " ++ show mikeD3
#+END_SRC

#+BEGIN_SRC haskell
read "Person3 {firstName = \"Michael\", lastName = \"Diamond\", age = 43}" :: Person3
#+END_SRC

**** 출처
***** Ch 7 pp.127~132



* 함수
** 가드(guard)와 where의 구문은?
*** .
**** 표현식이 아닌 문법 요소이기 때문에 함수 선언 구문에서 작성 가능한 위치가 정해져 있음
**** ex
#+BEGIN_SRC haskell
:{
max' :: (Ord a) => a -> a -> a
max' a b
    | a > b     = a
    | otherwise = b
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
densityTell :: (RealFloat a) => a -> a -> String
densityTell mass volume
    | mass / volume < 1.2 = "Wow! You're going for a ride in the sky!"
    | mass / volume <= 1000.0 = "Have fun swimming, but watch out for sharks!"
    | otherwise   = "If it's sink or swim, you're going to sink."
:}
densityTell 400 1
#+END_SRC

#+BEGIN_SRC haskell
:{
myCompare :: (Ord a) => a -> a -> Ordering
a `myCompare` b
    | a > b     = GT
    | a == b    = EQ
    | otherwise = LT
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
densityTell :: (RealFloat a) => a -> a -> String
densityTell mass volume
    | density < 1.2 = "Wow! You're going for a ride in the sky!"
    | density <= 1000.0 = "Have fun swimming, but watch out for sharks!"
    | otherwise   = "If it's sink or swim, you're going to sink."
    where density = mass / volume
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
densityTell :: (RealFloat a) => a -> a -> String
densityTell mass volume
    | density < air = "Wow! You're going for a ride in the sky!"
    | density <= water = "Have fun swimming, but watch out for sharks!"
    | otherwise   = "If it's sink or swim, you're going to sink."
    where density = mass / volume
          (air, water) = (1.2, 1000.0)
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
calcDensities :: (RealFloat a) => [(a, a)] -> [a]
calcDensities xs = [density m v | (m, v) <- xs]
    where density mass volume = mass / volume
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
initials :: String -> String -> String
initials firstname lastname = [f] ++ ". " ++ [l] ++ "."
    where (f:_) = firstname
          (l:_) = lastname
:}
#+END_SRC
**** 출처
***** Ch 3 pp.43~48





** let in 표현식, case 표현식의 구문은?
*** .
**** 표현식이기 때문에 값이 들어갈 수 있는 곳 어디에서나 사용 가능
**** ex

#+BEGIN_SRC haskell
:{
cylinder :: (RealFloat a) => a -> a -> a
cylinder r h =
    let sideArea = 2 * pi * r * h
        topArea = pi * r ^2
    in  sideArea + 2 * topArea
:}
cylinder 5 5
#+END_SRC

#+BEGIN_SRC haskell
4 * (let a = 9 in a + 1) + 2
#+END_SRC

#+BEGIN_SRC haskell
:{
[let square x = x * x in (square 5, square 3, square 2)]
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
(let a = 100; b = 200; c = 300 in a*b*c, let foo="Hey "; bar = "there!" in foo ++ bar)
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
(let (a,b,c) = (1,2,3) in a+b+c) * 100
-- 600
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
calcDensities :: (RealFloat a) => [(a, a)] -> [a]
calcDensities xs = [density | (m, v) <- xs, let density = m / v, density < 1.2]
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
head' :: [a] -> a
head' [] = error "No head for empty lists!"
head' (x:_) = x
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
head' :: [a] -> a
head' xs = case xs of [] -> error "No head for empty lists!"
                      (x:_) -> x
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
describeList :: [a] -> String
describeList xs = "The list is " ++ case xs of [] -> "empty."
                                               [x] -> "a singleton list."
                                               xs -> "a longer list."
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
describeList :: [a] -> String
describeList xs = "The list is " ++ what xs
    where what [] = "empty."
          what [x] = "a singleton list."
          what xs = "a longer list."
:}
#+END_SRC

**** 출처
***** Ch 3 pp.48~52






** 재귀함수를 구성하는 방법은?
*** .
**** 재귀가 더이상 적용되지 않는 base case를 먼저 생각해보자
**** ex
#+BEGIN_SRC haskell
:{
replicate' :: (Num i, Ord i) => i -> a -> [a]
replicate' n x
    | n <= 0    = []
    | otherwise = x:replicate' (n-1) x
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
zipWith' :: (a -> b -> c) -> [a] -> [b] -> [c]
zipWith' _ [] _ = []
zipWith' _ _ [] = []
zipWith' f (x:xs) (y:ys) = f x y : zipWith' f xs ys
:}
#+END_SRC

**** 출처
***** Ch 4 pp.55,56 Ch 5 pp.68,69





*** Q.
reverse 함수를 재귀적으로 구성하면?
#+BEGIN_SRC haskell
:{
-- Answer
reverse'
:}
#+END_SRC

** 합성 함수의 구문은?
*** .
**** ex
#+BEGIN_SRC haskell
(f . g) x
#+END_SRC

#+BEGIN_SRC haskell
f (g x))
#+END_SRC

#+BEGIN_SRC haskell
(f . g . h) x
#+END_SRC

#+BEGIN_SRC haskell
f (g (h x))
#+END_SRC

#+BEGIN_SRC haskell
sum (replicate 5 (max 6.7 8.9))
#+END_SRC

#+BEGIN_SRC haskell
(sum . replicate 5 . max 6.7) 8.9
#+END_SRC

#+BEGIN_SRC haskell
sum . replicate 5 . max 6.7 $ 8.9
#+END_SRC

#+BEGIN_SRC haskell
:{
map (\x -> negate (abs x)) [5,-3,-6,7,-3,2,-19,24]
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
map (negate . abs) [5,-3,-6,7,-3,2,-19,24]
:}
#+END_SRC

#+BEGIN_SRC haskell
(.) :: (b -> c) -> (a -> b) -> a -> c
f . g = \x -> f (g x)
#+END_SRC

**** 출처
***** Ch 7 pp.113~117,121~125




***** Ch 5 pp.87~90


*** Q.
#+BEGIN_SRC haskell
fn x = ceiling (negate (tan (cos (max 50 x))))
#+END_SRC

위의 fn을 합성 함수를 이용해서 간단히 나타내보면?

#+BEGIN_SRC haskell
:{
-- Answer
fn
#+END_SRC

* 펑터
** 타입을 타입클래스의 인스턴스로 만드는 구문은?
*** .
**** instance <타입클래스> <타입 생성자 + (타입 변수)> where
**** ex
#+BEGIN_SRC haskell
:{
class Eq a where
    (==) :: a -> a -> Bool
    (/=) :: a -> a -> Bool
    x == y = not (x /= y)
    x /= y = not (x == y)
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
data TrafficLight = Red | Yellow | Green

instance Eq TrafficLight where
    Red == Red = True
    Green == Green = True
    Yellow == Yellow = True
    _ == _ = False
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
Red == Red
-- True
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
Red == Yellow
-- False
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
Red `elem` [Red, Yellow, Green]
-- True
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
instance Show TrafficLight where
    show Red = "Red light"
    show Yellow = "Yellow light"
    show Green = "Green light"
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
[Red, Yellow, Green]
-- [Red light,Yellow light,Green light]
:}
#+END_SRC

#+BEGIN_SRC haskell
data Maybe a = Nothing | Just a
#+END_SRC

#+BEGIN_SRC haskell
:{
instance Eq (Maybe m) where
    Just x == Just y = x == y
    Nothing == Nothing = True
    _ == _ = False
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
instance (Eq m) => Eq (Maybe m) where
    Just x == Just y = x == y
    Nothing == Nothing = True
    _ == _ = False
:}
#+END_SRC

**** 출처
***** Ch 7 pp.144~149






** 참고
*** .
**** Kind : 타입의 타입
**** ex
#+BEGIN_SRC haskell
:{
:k Int
-- Int :: *
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
:k Maybe
-- Maybe :: * -> *
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
:k Maybe Int
-- Maybe Int :: *
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
:k Either
-- Either :: * -> * -> *
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
:k Either String
-- Either String :: * -> *
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
:k Either String Int
-- Either String Int :: *
:}
#+END_SRC

**** 출처
***** Ch 7 pp.157~159





*** Q.
** 펑터 타입클래스가 구현하려는 연산은?
*** .
**** 기존의 연산을, 타입으로 주어지는 "맥락" 하에서의 연산으로 재정의하고자 함
**** 기존의 함수를, 타입으로 주어지는 "맥락" 하에서의 함수로 재정의하고자 함
**** 펑터 : 기존의 합성 함수 구조를 타입으로 주어지는 "맥락" 하에서도 유지 하자
**** 펑터 규칙 2가지
***** fmap id = id
***** fmap (f . g) = fmap f . fmap g
**** ex
#+BEGIN_SRC haskell
:{
class Eq a where
    (==) :: a -> a -> Bool
    (/=) :: a -> a -> Bool
    x == y = not (x /= y)
    x /= y = not (x == y)

data TrafficLight = Red | Yellow | Green

instance Eq TrafficLight where
    Red == Red = True
    Green == Green = True
    Yellow == Yellow = True
    _ == _ = False
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
class Functor f where
    fmap :: (a -> b) -> f a -> f b

instance Functor [] where
    fmap = map
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
fmap (*2) [1..3]
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
map (*2) [1..3]
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
fmap ((*2) . (+1)) [1..3]
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
instance Functor Maybe where
    fmap f (Just x) = Just (f x)
    fmap f Nothing = Nothing
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
fmap (++ " HEY GUYS IM INSIDE THE JUST") (Just "Something serious.")
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
fmap (++ " HEY GUYS IM INSIDE THE JUST") Nothing
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
fmap (*2) (Just 200)
-- Just 400
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
fmap (*2) Nothing
-- Nothing
:}
#+END_SRC

#+BEGIN_SRC haskell
data Either a b = Left a | Right b
#+END_SRC

#+BEGIN_SRC haskell
:{
Left "Haedosa"
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
Right 20
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
:t Left "Haedosa"
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
:t Right 20
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
instance Functor (Either a) where
    fmap f (Right x) = Right (f x)
    fmap f (Left x) = Left x
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
fmap (*2) (Left "Haedosa")
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
fmap (*2) (Right 20)
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
instance Functor ((->) r) where
    fmap f g = (\x -> f (g x))
:}
#+END_SRC

#+BEGIN_SRC haskell
:t fmap (*3) (+100)
#+END_SRC

#+BEGIN_SRC haskell
fmap (*3) (+100) 1
#+END_SRC

#+BEGIN_SRC haskell
:{
(*3) `fmap` (+100) $ 1
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
(*3) . (+100) $ 1
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
fmap (show . (*3)) (*100) 1
:}
#+END_SRC

***** fmap id = id
#+BEGIN_SRC haskell
:{
fmap id (Just 3)
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
id (Just 3)
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
fmap id [1..5]
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
id [1..5]
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
fmap id []
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
fmap id Nothing
:}
#+END_SRC

***** fmap (f . g) = fmap f . fmap g
#+BEGIN_SRC haskell
:{
fmap ((*2) . (+1)) [1..3]
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
fmap (*2) . fmap (+1) $ [1..3]
:}
#+END_SRC

**** 출처
***** Ch 7 pp.152~157, Ch 11 pp.232~239





*** Q.
아래 코드들의 결과는?
#+BEGIN_SRC haskell
:{
fmap (replicate 3) [1, 2, 3, 4]
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
fmap (replicate 3) Nothing
:}
#+END_SRC

* 어플리커티브 펑터, 모노이드와 모나드
** 어플리커티브 펑터가 구현하려는 연산은?
*** .
**** 타입 = "맥락"
**** 펑터와 거의 같음
***** fmap f x = pure f <*> x
**** 어떤 "맥락" 하에서의 함수를, 다른 "맥락" 하에서의 함수로 재정의하고자 함
**** "맥락"안의 값이 맥락에 영향을 주지 않는다
***** 즉, "맥락"이 유지된다
***** "맥락"안의 값이 맥락에 독립적이다
**** 어플리커티브 규칙 4가지
***** Identity : pure id <*> v = v
***** Composition : pure (.) <*> u <*> v <*> w = u <*> (v <*> w)
u = pure f
v = pure g
w = pure x
일 경우
pure (.) <*> pure f <*> pure g <*> pure x = pure f <*> (pure g <*> pure x)

LHS :
  pure (.) <*> pure f <*> pure g <*> pure x
= pure ((.) f) <*> pure g <*> pure x
= pure ((.) f g) <*> pure x
= pure (f . g) <*> pure x
= (<*>) (pure (f . g)) (pure x)

= pure (f . g x)

RHS :
  pure f <*> (pure g <*> pure x)
= pure f <*> ((<*>) (pure g) (pure x))
= (<*>) (pure f) ((<*>) (pure g) (pure x))
= (<*>) (pure f) . (<*>) (pure g) (pure x)

= pure f <*> (pure g x)
= pure (f (g x))
= pure (f . g x)

#+BEGIN_SRC haskell
(.) :: (b -> c) -> (a -> b) -> a -> c
f . g = \x -> f (g x)
#+END_SRC
***** pure f <*> pure x = pure (f x)
***** u <*> pure y = pure ($ y) <*> u
**** ex
#+BEGIN_SRC haskell
:{
class (Functor f) => Applicative f where
    pure :: a -> f a
    (<*>) :: f (a -> b) -> f a -> f b
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
instance Applicative Maybe where
    pure = Just
    Nothing <*> _ = Nothing
    (Just f) <*> something = fmap f something
:}
#+END_SRC

#+BEGIN_SRC haskell
Just (+3) <*> Just 9
#+END_SRC

#+BEGIN_SRC haskell
Just (++"hahah") <*> Nothing
#+END_SRC

#+BEGIN_SRC haskell
Nothing <*> Just "woot"
#+END_SRC

#+BEGIN_SRC haskell
:{
pure (+) <*> Just 3 <*> Just 5
-- Just 8
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
pure (+) <*> Just 3 <*> Nothing
-- Nothing
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
(<$>) :: (Functor f) => (a -> b) -> f a -> f b
f <$> x = fmap f x
:}
#+END_SRC

#+BEGIN_SRC haskell
(++) <$> Just "johntra" <*> Just "volta"
#+END_SRC

#+BEGIN_SRC haskell
:{
instance Applicative ((->) r) where
    pure x = (\_ -> x)
    f <*> g = \x -> f x (g x)
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
(\x y z -> [x,y,z]) <$> (+3) <*> (*2) <*> (/2) $ 5
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
instance Applicative ZipList where
        pure x = ZipList (repeat x)
        ZipList fs <*> ZipList xs = ZipList (zipWith (\f x -> f x) fs xs)
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
getZipList $ (+) <$> ZipList [1,2,3] <*> ZipList [100,100,100]
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
getZipList $ max <$> ZipList [1,2,3,4,5,3] <*> ZipList [5,3,1,2]
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
getZipList $ (,,) <$> ZipList "dog" <*> ZipList "cat" <*> ZipList "rat"
:}
#+END_SRC

**** 출처
***** Ch 11 pp.239~247,pp.248~251






** 참고 -
*** .
**** 왼쪽/오른쪽 결합성 (left/right associative)
***** 그냥 결합성(associative)과는 다른 개념!
#+BEGIN_SRC haskell
"la" ++ ("di" ++ "da") == ("la" ++ "di") ++ "da"
#+END_SRC

#+BEGIN_SRC haskell
5 - (3 - 4) == (5 - 3) - 4
#+END_SRC

***** f<띄어쓰기>x : 왼쪽
***** (<*>) : 왼쪽
***** (.) : 오른쪽
***** ($) : 오른쪽
***** (++) : 오른쪽
***** (->) : 오른쪽
**** ex
#+BEGIN_SRC haskell
f a b == (f a) b

pure (+) <*> Just 3 <*> Just 5 == (pure (+) <*> Just 3) <*> Just 5

f . g . h == f . (g . h)

f $ g $ h == f $ (g $ h)

f $ g $ h x == f $ (g $ h x) == f (g (h x))

[1,2] ++ [3,4] ++ [5,6] == [1,2] ++ ([3,4] ++ [5,6])

\x -> \y -> x + y == \x -> (\y -> x + y)

f :: a -> b -> c == f :: a -> (b -> c)
#+END_SRC

**** 출처
***** Ch







** 모노이드가 구현하려는 연산은?
*** .
**** (좌,우)항등원이 존재하고 결합법칙을 만족하는 연산을 구현할 때 사용
**** 모노이드 규칙 3가지
***** mempty `mappend` x = x
***** x `mappend` mempty = x
***** (x `mappend` y) `mappend` z = x `mappend` (y `mappend` z)
**** ex
#+BEGIN_SRC haskell
:{
class Monoid m where
    mempty :: m
    mappend :: m -> m -> m
    mconcat :: [m] -> m
    mconcat = foldr mappend mempty
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
4 * 1
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
1 * 9
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
("one" `mappend` "two") `mappend` "tree"
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
"one" `mappend` ("two" `mappend` "tree")
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
"one" `mappend` "two" `mappend` "tree"
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
"pang" `mappend` mempty
:}
#+END_SRC


#+BEGIN_SRC haskell
:{
[1,2,3] ++ []
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
[] ++ [0.5, 2.5]
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
instance Monoid a => Monoid (Maybe a) where
    mempty = Nothing
    Nothing `mappend` m = m
    m `mappend` Nothing = m
    Just m1 `mappend` Just m2 = Just (m1 `mappend` m2)
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
Nothing `mappend` Just "andy"
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
Just LT `mappend` Nothing
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
Just (Sum 3) `mappend` Just (Sum 4)
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
newtype First a = First { getFirst :: Maybe a }
    deriving (Eq, Ord, Read, Show)
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
instance Monoid (First a) where
    mempty = First Nothing
    First (Just x) `mappend` _ = First (Just x)
    First Nothing `mappend` x = x
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
getFirst $ First (Just 'a') `mappend` First (Just 'b')
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
getFirst $ First Nothing `mappend` First (Just 'b')
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
getFirst $ First (Just 'a') `mappend` First Nothing
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
instance Monoid [a] where
    mempty = []
    mappend = (++)
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
[1,2,3] `mappend` [4,5,6]
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
mconcat [[1,2],[3,6],[9]]
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
mempty :: [a]
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
newtype Product a =  Product { getProduct :: a }
    deriving (Eq, Ord, Read, Show, Bounded)
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
instance Num a => Monoid (Product a) where
    mempty = Product 1
    Product x `mappend` Product y = Product (x * y)
:}
#+END_SRC

#+BEGIN_SRC haskell
getProduct $ Product 3 `mappend` Product 9
#+END_SRC

#+BEGIN_SRC haskell
getProduct $ Product 3 `mappend` mempty
#+END_SRC

#+BEGIN_SRC haskell
getProduct $ Product 3 `mappend` Product 4 `mappend` Product 2
#+END_SRC

#+BEGIN_SRC haskell
getProduct . mconcat . map Product $ [3,4,2]
#+END_SRC

#+BEGIN_SRC haskell
:{
getSum . mconcat . map Sum $ [1,2,3]
-- 6
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
getSum . mconcat . map Sum $ [1,2,3]
-- 6
:}
#+END_SRC

**** 출처
***** Ch 12 pp.265~277



** 모나드가 구현하려는 연산은? -
*** .
**** 타입 = "맥락"
**** "맥락"안의 값이 맥락에 영향을 준다
***** 즉, "맥락"이 변화한다
***** "맥락"안의 값이 맥락에 의존적이다

**** 모나드 규칙 4가지
***** Left identity : return x >>= f = f x
***** Right identity : m >>= return = m
***** Associativity : (m >>= f) >>= g = m >>= (\x -> f x >>= g)
**** ex
#+BEGIN_SRC haskell
:{
class Monad m where
    return :: a -> m a

    (>>=) :: m a -> (a -> m b) -> m b

    (>>) :: m a -> m b -> m b
    x >> y = x >>= \_ -> y

    fail :: String -> m a
    fail msg = error msg
:}
#+END_SRC

#+BEGIN_SRC haskell
:{
type Birds = Int
type Pole = (Birds,Birds)

landLeft :: Birds -> Pole -> Pole
landLeft n (left,right) = (left + n,right)

landRight :: Birds -> Pole -> Pole
landRight n (left,right) = (left,right + n)
:}
#+END_SRC

#+BEGIN_SRC haskell
landLeft 2 (0,0)
#+END_SRC

#+BEGIN_SRC haskell
landRight 1 (1,2)
#+END_SRC

#+BEGIN_SRC haskell
landRight (-1) (1,2)
#+END_SRC

#+BEGIN_SRC haskell
landLeft 2 (landRight 1 (landLeft 1 (0,0)))
#+END_SRC

#+BEGIN_SRC haskell
x -: f = f x
#+END_SRC

#+BEGIN_SRC haskell
100 -: (*3)
#+END_SRC

#+BEGIN_SRC haskell
True -: not
#+END_SRC

#+BEGIN_SRC haskell
(0,0) -: landLeft 2
#+END_SRC

#+BEGIN_SRC haskell
(0,0) -: landLeft 1 -: landRight 1 -: landLeft 2
#+END_SRC

#+BEGIN_SRC haskell
landLeft 10 (0,3)
#+END_SRC


#+BEGIN_SRC haskell
(0,0) -: landLeft 1 -: landRight 4 -: landLeft (-1) -: landRight (-2)
#+END_SRC

#+BEGIN_SRC haskell
:{
landLeft :: Birds -> Pole -> Maybe Pole
landLeft n (left,right)
    | abs ((left + n) - right) < 4 = Just (left + n, right)
    | otherwise                    = Nothing

landRight :: Birds -> Pole -> Maybe Pole
landRight n (left,right)
    | abs (left - (right + n)) < 4 = Just (left, right + n)
    | otherwise                    = Nothing
:}
#+END_SRC

#+BEGIN_SRC haskell
landLeft 2 (0,0)
#+END_SRC

#+BEGIN_SRC haskell
landLeft 10 (0,3)
#+END_SRC

#+BEGIN_SRC haskell
landRight 1 (0,0) >>= landLeft 2
#+END_SRC

#+BEGIN_SRC haskell
Nothing >>= landLeft 2
#+END_SRC

#+BEGIN_SRC haskell
return (0,0) >>= landRight 2 >>= landLeft 2 >>= landRight 2
#+END_SRC

#+BEGIN_SRC haskell
(0,0) -: landLeft 1 -: landRight 4 -: landLeft (-1) -: landRight (-2)
#+END_SRC

#+BEGIN_SRC haskell
return (0,0) >>= landLeft 1 >>= landRight 4 >>= landLeft (-1) >>= landRight (-2)
#+END_SRC

#+BEGIN_SRC haskell
:{
banana :: Pole -> Maybe Pole
banana _ = Nothing
:}
#+END_SRC

#+BEGIN_SRC haskell
return (0,0) >>= landLeft 1 >>= banana >>= landRight 1
#+END_SRC

**** 출처
***** Ch 12






* etc.
** ?
*** .
**** .
**** ex
**** 출처
***** Ch 7 pp.152~157, Ch 11 pp.235~239





*** Q.
* List and Tuple
** list,tuple comprehension
** pattern matching and recursion
** fold and map (lazy, strict, thunk)


* Types and Typeclasses
** data, type, and newtype
** type and value constructors
** algebraic data type
** recursive data structures
** type class and type instance


* Function
** type annotation
** let in, where
** if, case, guard
** lambda
** recursion
** higher order function (currying)


* Functor
** functor law
** fmap
** instances of functor


* Applicative Functor and Monad
** applicative law
** monad law
** instances of applicative functor and monad
** IO
** examples


* etc.
